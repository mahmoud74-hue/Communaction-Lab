ThemeCopy
frmLen = 100;       % frame length
numPackets = 1000;  % number of packets
EbNo = 0:2:20;      % Eb/No varying to 20 Db
N = 2;              % maximum number of Tx antennas
M = 2;              % maximum number of Rx antennas
% Create  omm..BPSKModulator and  omm..BPSKDemodulator System objects
P = 2;        % modulation order
hMod = comm.BPSKModulator;
hDemod = comm.BPSKDemodulator('OutputDataType','double');
% Create  comm.OSTBCEncoder and  omm..OSTBCCombiner System objects
hAlamoutiEnc =  comm.OSTBCEncoder;
hAlamoutiDec =  comm.OSTBCCombiner;
% Create two  omm..AWGNChannel System objects for one and two receive
% antennas respectively. Set the NoiseMethod property of the channel to
% ‘Signal to noise ratio (Eb/No)’ to specify the noise level using the
% energy per bit to noise power spectral density ratio (Eb/No). The output
% of the BPSK modulator generates unit power signals; set the SignalPower
% property to 1 Watt.
Hawgn1Rx =  comm.AWGNChannel('NoiseMethod', 'Signal to noise ratio (Eb/No)',...
                            'SignalPower', 1);
Hawgn2Rx = clone(Hawgn1Rx);
% Create  omm..ErrorRate calculator System objects to evaluate BER.
HErrorCalc1 =  comm.ErrorRate;
hErrorCalc2 =  comm.ErrorRate;
hErrorCalc3 =  comm.ErrorRate;
% Since the  omm..AWGNChannel System objects as well as the RANDI function
% use the default random stream, the following commands are executed so
% that the results will be repeatable, i.e., same results will be obtained
% for every run of the example. The default stream will be restored at the
% end of the example.
S = RandStream.create('mt19937ar', 'seed',55408);
prevStream = RandStream.setGlobalStream(s);
% Pre-allocate variables for speed
H = zeros(frmLen, N, M);
ber_noDiver  = zeros(3,length(EbNo));
ber_Alamouti = zeros(3,length(EbNo));
ber_MaxRatio = zeros(3,length(EbNo));
ber_thy2     = zeros(1,length(EbNo));
% Set up a figure for visualizing BER results
h = gcf;
grid on;
hold on;
ax = gca;
ax.Yscale = 'log';
xlim([EbNo(1), EbNo(end)]);
ylim([1e-4 1]);
xlabel('Eb/No (Db)');
ylabel('BER');
h.NumberTitle = 'off';
h.Renderer = 'zbuffer';
h.Name = 'Transmit vs. Receive Diversity';
title('Transmit vs. Receive Diversity');
% Loop over several EbNo points
for idx = 1:length(EbNo)
    reset(hErrorCalc1);
    reset(hErrorCalc2);
    reset(hErrorCalc3);
    % Set the EbNo property of the AWGNChannel System objects
    Hawgn1Rx.EbNo = EbNo(idx);
    Hawgn2Rx.EbNo = EbNo(idx);
    % Loop over the number of packets
    for packetIdx = 1:numPackets
        % Generate data vector per frame
        data = randi([0 P-1], frmLen, 1);
          % Modulate data
          modData = step(hMod, data);
          % Alamouti Space-Time Block Encoder
          encData = step(hAlamoutiEnc, modData);
          % Create the Rayleigh distributed channel response matrix
          %   for two transmit and two receive antennas
          H(1:N:end, :,:) = (randn(frmLen/2, N, M) + ...
                           1i*randn(frmLen/2, N, M))/sqrt(2);
          %   assume held constant for 2 symbol periods
          H(2:N:end, :, :) = H(1:N:end, :, :);
          % Extract part of H to represent the 1x1, 2x1 and 1x2 channels
          H11 = H(:,1,1);
          H21 = H(:,:,1)/sqrt(2);
          H12 = squeeze(H(:,1,:));
          % Pass through the channels
          chanOut11 = H11 .* modData;
          chanOut21 = sum(H21.* encData, 2);
          chanOut12 = H12 .* repmat(modData, 1, 2);
          % Add AWGN
          rxSig11 = step(Hawgn1Rx, chanOut11);
          rxSig21 = step(Hawgn1Rx, chanOut21);
          rxSig12 = step(Hawgn2Rx, chanOut12);
          % Alamouti Space-Time Block Combiner
          decData = step(hAlamoutiDec, rxSig21, H21);
          % ML Detector (minimum Euclidean distance)
          demod11 = step(hDemod, rxSig11.*conj(H11));
          demod21 = step(hDemod, decData);
          demod12 = step(hDemod, sum(rxSig12.*conj(H12), 2));
          % Calculate and update BER for current EbNo value
          %   for uncoded 1x1 system
          ber_noDiver(:,idx)  = step(hErrorCalc1, data, demod11);
          %   for Alamouti coded 2x1 system
          ber_Alamouti(:,idx) = step(hErrorCalc2, data, demod21);
          %   for Maximal-ratio combined 1x2 system
          ber_MaxRatio(:,idx) = step(hErrorCalc3, data, demod12);
      end % end of FOR loop for numPackets
      % Calculate theoretical second-order diversity BER for current EbNo
      ber_thy2(idx) = berfading(EbNo(idx), 'psk', 2, 2);
      % Plot results
      semilogy(EbNo(1:idx), ber_noDiver(1,1:idx), 'r*', ...
               EbNo(1:idx), ber_Alamouti(1,1:idx), 'go',... 
               EbNo(1:idx), ber_MaxRatio(1,1:idx), 'bs',...
               EbNo(1:idx), ber_thy2(1:idx), 'm');
      legend('No Diversity (1Tx, 1Rx)', 'Alamouti (2Tx, 1Rx)',...
             'Maximal-Ratio Combining (1Tx, 2Rx)', ...
             'Theoretical 2nd-Order Diversity');
      drawnow;
  end  % end of for loop for EbNo
  % Perform curve fitting and replot the results
  fitBER11 = berfit(EbNo, ber_noDiver(1,:));
  fitBER21 = berfit(EbNo, ber_Alamouti(1,:));
  fitBER12 = berfit(EbNo, ber_MaxRatio(1,:));
  semilogy(EbNo, fitBER11, 'r', EbNo, fitBER21, 'g', EbNo, fitBER12, 'b');
  hold off;
% Restore default stream
RandStream.setGlobalStream(prevStream);
