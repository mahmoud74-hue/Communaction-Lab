
clear; close all; clc;

% Parameters
nTx = 2;           
nRx = 2;          
Nfft = 64;         
Ncp = 16;          
L = 4;             
NofdmSym = 100;    
NtSymbols = NofdmSym * Nfft; 
SNRdB = 0:2:20;    % SNR range
numSNR = length(SNRdB);

rng(2025); 

% Pre-generate channel(same channel for both modulations)
numBlocks = NofdmSym;
channelTapsAll = cell(numBlocks,1);
for blk = 1:numBlocks
    H_taps = zeros(nRx, nTx, L);
    for l = 1:L
        H_taps(:,:,l) = (randn(nRx,nTx) + 1j*randn(nRx,nTx))/sqrt(2*L);
    end
    channelTapsAll{blk} = H_taps;
end

% Precompute H_freq (nRx x nTx x Nfft x numBlocks)
H_freq = zeros(nRx, nTx, Nfft, numBlocks);
for blk = 1:numBlocks
    H_taps = channelTapsAll{blk};
    for rx = 1:nRx
        for tx = 1:nTx
            h = squeeze(H_taps(rx,tx,:));
            h_padded = [h; zeros(Nfft - length(h), 1)];
            Hf = fft(h_padded, Nfft);
            H_freq(rx,tx,:,blk) = Hf;
        end
    end
end

%Compare modulations
modOrderList = [4, 16]; % 4 -> QPSK, 16 -> 16-QAM
BER_results = zeros(length(modOrderList), numSNR);
detectedSymbols_last = cell(length(modOrderList),1); % store last run symbols for constellation
S_tx_all = cell(length(modOrderList),1);              % store transmitted symbols matrix per mod
symStream_all = cell(length(modOrderList),1);         % store symbol streams (per tx) per mod

for mIdx = 1:length(modOrderList)
    M = modOrderList(mIdx);
    bitsPerSymbol = log2(M);
    
    % Generate random bits for each transmit antenna
    bits_tx = randi([0 1], nTx, NtSymbols * bitsPerSymbol); % rows: tx, cols: bits
    
    % Map bits -> symbols 
    symStream = cell(nTx,1);
    for tx = 1:nTx
        b = bits_tx(tx,:);
        bmat = reshape(b, bitsPerSymbol, []).'; % each row = one symbol
        if M == 4
            % QPSK Gray: (1-2*b0) + j*(1-2*b1) normalized by sqrt(2)
            sym = (1/sqrt(2)) * ((1-2*bmat(:,1)) + 1j*(1-2*bmat(:,2)));
        else
            % 16-QAM Gray mapping: bits [b1 b2 b3 b4] -> I bits = b1,b2 ; Q bits = b3,b4
            nSym = size(bmat,1);
            Ilev = zeros(nSym,1);
            Qlev = zeros(nSym,1);
            ibits = bmat(:,1:2);
            qbits = bmat(:,3:4);
           
            Ilev(ibits(:,1)==0 & ibits(:,2)==0) = -3;
            Ilev(ibits(:,1)==0 & ibits(:,2)==1) = -1;
            Ilev(ibits(:,1)==1 & ibits(:,2)==1) =  1;
            Ilev(ibits(:,1)==1 & ibits(:,2)==0) =  3;
            % Q levels
            Qlev(qbits(:,1)==0 & qbits(:,2)==0) = -3;
            Qlev(qbits(:,1)==0 & qbits(:,2)==1) = -1;
            Qlev(qbits(:,1)==1 & qbits(:,2)==1) =  1;
            Qlev(qbits(:,1)==1 & qbits(:,2)==0) =  3;
            % Normalize power: average symbol energy = 5 for 16-QAM with levels +/-1,+/-3
            sym = (Ilev + 1j*Qlev)/sqrt(5);
        end
        symStream{tx} = sym;
    end
    
    
    S_tx = zeros(nTx, Nfft, numBlocks);
    for tx = 1:nTx
        S_tx(tx,:,:) = reshape(symStream{tx}, Nfft, numBlocks);
    end
    S_tx_all{mIdx} = S_tx;
    symStream_all{mIdx} = symStream;
    
    
    for idx = 1:numSNR
        snr_db = SNRdB(idx);
        snr_lin = 10^(snr_db/10);
        noiseVar = 1/snr_lin; % signal energy normalized to 1
        
        % Received symbols container
        rxSymbolsAll = zeros(nRx, Nfft, numBlocks);
        for blk = 1:numBlocks
            for sc = 1:Nfft
                Hk = squeeze(H_freq(:,:,sc,blk)); 
                xk = squeeze(S_tx(:,sc,blk));     
                nVec = sqrt(noiseVar/2) * (randn(nRx,1) + 1j*randn(nRx,1));
                yk = Hk * xk + nVec;
                rxSymbolsAll(:,sc,blk) = yk;
            end
        end
        
        % Receiver: ZF per subcarrier
        detectedSymbols = zeros(nTx, Nfft, numBlocks);
        for blk = 1:numBlocks
            for sc = 1:Nfft
                Hk = squeeze(H_freq(:,:,sc,blk)); % nRx x nTx
                yk = rxSymbolsAll(:,sc,blk);
                x_hat = pinv(Hk) * yk; % nTx x1
                detectedSymbols(:,sc,blk) = x_hat;
            end
        end
        
        % Demap detectedSymbols -> bits and compute BER
        rxBitsAll = [];
        txBitsAll = [];
        for tx = 1:nTx
            det = reshape(detectedSymbols(tx,:,:), Nfft*numBlocks, 1); % complex
            if M == 4
                % QPSK demap via sign
                b0_hat = real(det) < 0; % MSB
                b1_hat = imag(det) < 0; % LSB
                rxBits = zeros(length(det)*2,1);
                rxBits(1:2:end) = b0_hat;
                rxBits(2:2:end) = b1_hat;
            else
           
                levels = [-3 -1 1 3];
                cmap = [];
                cmap_bits = [];
                for i1 = 1:4
                    for q1 = 1:4
                        Ilev = levels(i1);
                        Qlev = levels(q1);
                        sym_point = (Ilev + 1j*Qlev)/sqrt(5);
                        cmap = [cmap; sym_point]; %#ok<AGROW>
                        switch i1
                            case 1, Ibits = [0 0];
                            case 2, Ibits = [0 1];
                            case 3, Ibits = [1 1];
                            case 4, Ibits = [1 0];
                        end
                        switch q1
                            case 1, Qbits = [0 0];
                            case 2, Qbits = [0 1];
                            case 3, Qbits = [1 1];
                            case 4, Qbits = [1 0];
                        end
                        cmap_bits = [cmap_bits; Ibits Qbits]; %#ok<AGROW>
                    end
                end
                rxBits = zeros(length(det)*4,1);
                for sidx = 1:length(det)
                    [~, indmin] = min(abs(det(sidx) - cmap));
                    bits_sym = cmap_bits(indmin, :); % 1x4
                    pos = (sidx-1)*4;
                    rxBits(pos+1:pos+4) = bits_sym.';
                end
            end
            rxBitsAll = [rxBitsAll; rxBits]; %#ok<AGROW>
            
            txb = bits_tx(tx,:).';
            txBitsAll = [txBitsAll; txb]; %#ok<AGROW>
        end % tx loop
        
        numErr = sum(txBitsAll ~= rxBitsAll);
        BER_results(mIdx, idx) = numErr/length(txBitsAll);
        
        % store last detectedSymbols of last SNR for plotting constellations
        if idx == numSNR
            detectedSymbols_last{mIdx} = detectedSymbols;
        end
    end 
    
    fprintf('Done modulation M=%d\n', M);
end 

% Plot BER comparison
figure;
semilogy(SNRdB, BER_results(1,:), '-o', 'LineWidth',1.6, 'DisplayName','QPSK');
hold on;
semilogy(SNRdB, BER_results(2,:), '-s', 'LineWidth',1.6, 'DisplayName','16-QAM');
grid on; legend('Location','southwest');
xlabel('SNR (dB)');
ylabel('BER');
title('BER Comparison: QPSK vs 16-QAM (2x2 MIMO-OFDM, ZF equalizer)');

% Plot Constellations (last SNR run)

% QPSK constellation (TX1)
det_qpsk = reshape(detectedSymbols_last{1}(1,:,:), Nfft*numBlocks, 1);
figure;
plot(real(det_qpsk(1:min(500,length(det_qpsk)))), imag(det_qpsk(1:min(500,length(det_qpsk)))), '.');
grid on; axis equal;
xlabel('In-Phase'); ylabel('Quadrature');
title('Equalized Constellation (QPSK) - TX1 - (samples)');

% 16-QAM constellation (TX1)
det_16qam = reshape(detectedSymbols_last{2}(1,:,:), Nfft*numBlocks, 1);
figure;
plot(real(det_16qam(1:min(500,length(det_16qam)))), imag(det_16qam(1:min(500,length(det_16qam)))), '.');
grid on; axis equal;
xlabel('In-Phase'); ylabel('Quadrature');
title('Equalized Constellation (16-QAM) - TX1 - (samples)');



% 1) Channel Frequency Response (magnitude)plot for block 1 (all tx->rx)
blk0 = 1;
figure;
hold on;
leg = {};
for rx = 1:nRx
    for tx = 1:nTx
        plot(0:Nfft-1, 20*log10(abs(squeeze(H_freq(rx,tx,:,blk0))) + eps));
        leg{end+1} = sprintf('H_{%d%d}', rx, tx); %#ok<AGROW>
    end
end
grid on;
xlabel('Subcarrier index');
ylabel('|H(f)| (dB)');
title(sprintf('Channel Frequency Response per subcarrier (block %d)', blk0));
legend(leg,'Location','best');

% 2) Relative SNR / channel gain per subcarrier plot (using Frobenius norm of H_k)
Hpower = squeeze(sum(sum(abs(H_freq(:,:, :, blk0)).^2,1),2)); % 1 x Nfft
Hpower = reshape(Hpower, [Nfft,1]);
Hpower_dB = 10*log10(Hpower + eps);
Hpower_dB = Hpower_dB - max(Hpower_dB); % normalize to max = 0 dB
figure;
plot(0:Nfft-1, Hpower_dB, '-o');
grid on;
xlabel('Subcarrier index');
ylabel('Relative gain (dB)');
title('Relative channel gain per subcarrier (normalized)');

% 3) Power Spectral Density of transmitted signal plot (TX antenna 1, using QPSK mapping)

% Reconstruct time-domain TX for modulation 1 (QPSK)
S_tx_qpsk = S_tx_all{1}; 
tx_time_tx1 = [];
for blk = 1:numBlocks
    Xblk = squeeze(S_tx_qpsk(1,:,blk)); % subcarriers
    x_ifft = ifft(Xblk(:), Nfft);
    x_cp = [x_ifft(end-Ncp+1:end); x_ifft];
    tx_time_tx1 = [tx_time_tx1; x_cp];
end
figure;
try
    pwelch(tx_time_tx1, hamming(256), 128, 1024, 'centered');
    title('Power Spectral Density of transmitted OFDM signal (TX1, QPSK)');
catch
    NfftPSD = 1024;
    Pxx = abs(fft(tx_time_tx1, NfftPSD)).^2 / length(tx_time_tx1);
    freqs = linspace(-0.5,0.5,NfftPSD);
    plot(freqs, fftshift(10*log10(Pxx)));
    title('Power Spectrum (periodogram) of OFDM signal (TX1)');
    xlabel('Normalized Frequency');
    ylabel('Power (dB)');
    grid on;
end

% 4) Per-subcarrier error power (MSE) between transmitted and equalized symbols for last SNR

% For each modulation compute MSE per subcarrier across tx & blocks
for mIdx = 1:length(modOrderList)
    S_tx = S_tx_all{mIdx}; % nTx x Nfft x numBlocks
    detSym = detectedSymbols_last{mIdx}; % nTx x Nfft x numBlocks
    mse_perCarrier = zeros(Nfft,1);
    for sc = 1:Nfft
        diff = detSym(:,sc,:) - S_tx(:,sc,:); % nTx x 1 x numBlocks
        diff = diff(:);
        mse_perCarrier(sc) = mean(abs(diff).^2);
    end
    mse_dB = 10*log10(mse_perCarrier + eps);
    figure;
    plot(0:Nfft-1, mse_dB, '-s');
    grid on;
    xlabel('Subcarrier index');
    ylabel('MSE (dB)');
    title(sprintf('Per-subcarrier MSE (last SNR) - M = %d', modOrderList(mIdx)));
end


disp('Simulation finished. Plots: BER comparison, constellations, channel response, PSD, per-subcarrier error.');